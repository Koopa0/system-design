# Task Scheduler 系統設計文檔

## 問題定義

### 業務需求
構建分布式任務調度系統，用於：
- **延遲任務**：訂單 30 分鐘未支付自動取消
- **定時任務**：每日凌晨生成報表
- **週期任務**：每小時同步數據
- **超時處理**：會議室預訂超時釋放

### 技術指標
| 指標 | 目標值 | 挑戰 |
|------|--------|------|
| **精度** | 秒級 | 如何保證時間精度？ |
| **容量** | 100 萬任務 | 如何高效存儲？ |
| **延遲** | 調度延遲 < 1s | 如何快速觸發？ |
| **可靠性** | 不丟失、不重複 | 如何保證執行？ |
| **可擴展** | 水平擴展 | 如何分布式調度？ |

### 容量估算
```
假設：
- 電商平台日訂單：100 萬
- 每個訂單：30 分鐘支付超時任務
- 峰值係數：5x

計算：
- 日均任務數：100 萬
- 平均 QPS：100 萬 / 86400 ≈ 11.6 tasks/s
- 峰值 QPS：11.6 × 5 = 58 tasks/s
- 同時存活任務：100 萬 × (30 分鐘 / 24 小時) ≈ 2 萬個

存儲需求：
- 單個任務：1 KB（任務 ID、執行時間、回調數據）
- 100 萬任務 ≈ 1 GB（記憶體可承受）
```

---

## 設計決策樹

### 決策 1：延遲任務如何實現？

```
需求：30 分鐘後執行任務（如訂單超時取消）

方案 A：定時輪詢資料庫
   機制：
   - 每秒 SELECT * FROM tasks WHERE execute_time <= NOW()
   - 查詢到任務 → 執行 → 標記完成

   問題：
   - 低效：100 萬任務，每秒全表掃描
   - 資料庫壓力：SELECT 查詢消耗大量 I/O
   - 精度差：輪詢間隔 = 最小精度（1 秒輪詢 = 1 秒誤差）

   計算：
   - 100 萬任務 × 每秒掃描 = 巨大開銷
   - 索引優化後仍需掃描到期任務

方案 B：sleep + goroutine（每個任務一個 goroutine）
   機制：
   - 創建任務時：go func() { time.Sleep(30*minute); execute() }()

   問題：
   - 記憶體爆炸：100 萬任務 = 100 萬個 goroutine
   - 計算：每個 goroutine ~2KB，100 萬個 ≈ 2 GB 記憶體
   - 不可靠：進程重啟後所有任務丟失
   - 無法分布式：任務綁定在單一進程

方案 C：優先級隊列（Min-Heap）
   機制：
   - 按執行時間排序，最早的在堆頂
   - 定時檢查堆頂任務是否到期

   範例：
   Heap: [Task(10:00), Task(10:05), Task(10:30)]
         ↑ 堆頂（最早）

   問題：
   - 插入/刪除：O(log N)，可接受
   - 仍需定時輪詢堆頂
   - 大量任務時堆操作開銷大

選擇方案 D：時間輪算法（Timing Wheel）
   機制：
   - 圓形槽位數組（如時鐘）
   - 每個槽位存儲該時間段的任務
   - 指針定時轉動，觸發槽位任務

   範例（簡化版，60 個槽位 = 60 秒）：

   Slot 0 (10:00:00): [Task A, Task B]
   Slot 1 (10:00:01): []
   Slot 2 (10:00:02): [Task C]
   ...
   Slot 30 (10:00:30): [Task D] ← 30 秒後執行

   指針每秒轉動一格：
   T=0s → Slot 0 → 執行 Task A, B
   T=1s → Slot 1 → 無任務
   T=30s → Slot 30 → 執行 Task D

   優勢：
   - O(1) 插入：計算槽位 = (當前槽位 + 延遲秒數) % 槽位數
   - O(1) 觸發：只檢查當前槽位
   - 記憶體高效：任務按時間分散在槽位中
   - 高性能：Netty、Kafka 都使用此算法

   權衡：
   - 精度限制：槽位數 = 精度（60 槽位 = 秒級精度）
   - 長延遲任務：需要多圈（round）計數
```

**選擇：方案 D（時間輪算法）**

**實現細節：**
```go
// 時間輪配置
const (
    SlotCount = 3600  // 3600 個槽位 = 1 小時精度
    TickDuration = 1 * time.Second  // 每秒轉動一次
)

// 任務插入
slot := (currentSlot + delaySeconds) % SlotCount
round := delaySeconds / SlotCount  // 需要轉幾圈
wheel[slot].append(Task{ID: "xxx", Round: round})

// 指針轉動
for {
    time.Sleep(TickDuration)
    currentSlot = (currentSlot + 1) % SlotCount

    // 執行當前槽位的任務
    for task in wheel[currentSlot] {
        if task.Round == 0 {
            execute(task)  // 立即執行
        } else {
            task.Round--   // 圈數遞減
        }
    }
}
```

---

### 決策 2：如何保證任務持久化？

```
問題：進程重啟後任務不丟失

方案 A：只用記憶體（時間輪）
   問題：重啟後所有任務丟失

方案 B：只用資料庫（PostgreSQL）
   問題：性能差，無法秒級精度

選擇方案 C：時間輪（記憶體）+ NATS JetStream（持久化）
   機制：
   1. 任務創建 → 發送到 NATS（持久化）
   2. Worker 訂閱 → 加載到時間輪（記憶體）
   3. 時間到 → 執行 + ACK（從 NATS 刪除）

   流程：
   ┌─────────┐  1. Publish   ┌──────────┐
   │ Client  │──────────────>│   NATS   │
   └─────────┘               │JetStream │
                             └────┬─────┘
                                  │ 2. Subscribe
                             ┌────▼─────┐
                             │ Timing   │
                             │  Wheel   │
                             │(Memory)  │
                             └────┬─────┘
                                  │ 3. Time's up
                             ┌────▼─────┐
                             │ Execute  │
                             │   Task   │
                             └──────────┘

   優勢：
   - 性能：時間輪記憶體操作，O(1) 觸發
   - 可靠：NATS 持久化，重啟後恢復
   - 分布式：多個 Worker 共享 NATS 任務

   權衡：
   - 複雜度增加：需整合兩個組件
   - 重啟恢復時間：需重新加載所有任務到時間輪
```

**選擇：方案 C（時間輪 + NATS）**

---

### 決策 3：定時任務（Cron）如何實現？

```
需求：每天凌晨 2:00 生成報表

方案 A：計算下次執行時間，加入時間輪
   機制：
   - 解析 Cron 表達式："0 2 * * *"
   - 計算下次執行時間：明天 2:00
   - 加入時間輪
   - 執行後重新計算下次時間

   範例：
   當前時間：2025-01-15 10:00
   Cron: "0 2 * * *"
   下次執行：2025-01-16 02:00
   延遲秒數：16 小時 = 57600 秒

   槽位計算：
   slot = (currentSlot + 57600) % 3600
   round = 57600 / 3600 = 16 圈

   優勢：
   - 統一機制：複用時間輪
   - 簡單實現

   問題：
   - 長延遲任務：需要多圈計數
   - 時間輪槽位浪費：大部分槽位空閒

選擇方案 B：分層時間輪（教學簡化）
   機制：
   - 秒級輪：3600 槽位（1 小時）
   - 分鐘級輪：60 槽位（1 小時）
   - 小時級輪：24 槽位（1 天）

   任務降級：
   - 小時級到期 → 降級到分鐘級
   - 分鐘級到期 → 降級到秒級
   - 秒級到期 → 執行

   教學簡化：
   - 當前實現：單層時間輪 + round 計數
   - 生產環境可優化：多層時間輪（Kafka 使用）
```

**選擇：方案 A（單層時間輪 + round）**

**Cron 解析範例：**
```go
// 簡化的 Cron 解析（教學用）
// 格式："秒 分 時 日 月 週"
// 範例："0 0 2 * * *" = 每天 2:00

// 生產環境建議使用成熟庫：
// - github.com/robfig/cron
```

---

### 決策 4：如何處理任務執行失敗？

```
問題：執行任務時可能失敗（網絡錯誤、業務異常）

方案 A：忽略失敗
   問題：任務丟失

方案 B：立即重試
   問題：
   - 短時間內重複失敗
   - 可能加劇系統負載

選擇方案 C：指數退避重試
   機制：
   1. 第一次失敗：1 秒後重試
   2. 第二次失敗：2 秒後重試
   3. 第三次失敗：4 秒後重試
   4. ...
   5. 達到最大次數：進入死信隊列

   流程：
   Execute(task)
   ├─ 成功 → ACK → 刪除任務
   └─ 失敗 → 重新加入時間輪
            ├─ delay = 2^(retryCount) 秒
            ├─ retryCount++
            └─ if retryCount > maxRetries → Dead Letter Queue

   優勢：
   - 避免瞬時故障（網絡抖動）
   - 避免雪崩（給系統恢復時間）

   死信隊列（DLQ）：
   - 存儲多次失敗的任務
   - 人工介入處理
   - 告警通知
```

**選擇：方案 C（指數退避 + 死信隊列）**

---

### 決策 5：分布式調度如何避免重複執行？

```
問題：多個 Worker 實例，如何保證任務只執行一次？

方案 A：分布式鎖（Redis/etcd）
   機制：
   - 執行前：獲取鎖（task_id）
   - 執行完：釋放鎖
   - 未獲取到鎖：跳過（其他 Worker 已執行）

   問題：
   - 每個任務都要網絡調用（獲取鎖）
   - 性能開銷大

選擇方案 B：NATS Queue Groups（自動互斥）
   機制：
   - 多個 Worker 訂閱同一個 Queue Group
   - NATS 自動分配任務（每個任務只發給一個 Worker）
   - 無需額外鎖機制

   範例：
   Queue Group "task-scheduler"
   ├─ Worker 1 ──> 處理 Task A, D, G
   ├─ Worker 2 ──> 處理 Task B, E, H
   └─ Worker 3 ──> 處理 Task C, F, I

   每個任務只被一個 Worker 處理 ✅

   優勢：
   - 無鎖設計：NATS 內建機制
   - 高性能：無額外網絡調用
   - 自動容錯：Worker 崩潰 → 任務重新分配

   權衡：
   - 依賴 NATS：需 NATS 可用
```

**選擇：方案 B（NATS Queue Groups）**

---

## 架構設計

### 整體架構

```
┌──────────────────────────────────────────────────────────┐
│                      Client Layer                         │
│  ┌────────┐  ┌────────┐  ┌────────┐  ┌────────┐         │
│  │ Order  │  │Payment │  │ Room   │  │ Report │         │
│  │Service │  │Service │  │Service │  │Service │         │
│  └───┬────┘  └───┬────┘  └───┬────┘  └───┬────┘         │
│      │ AddTask   │           │           │               │
└──────┼───────────┼───────────┼───────────┼───────────────┘
       │           │           │           │
       └───────────┴───────────┴───────────┘
                      ↓
       ┌─────────────────────────────────────┐
       │      NATS JetStream (持久化)        │
       │  Stream: SCHEDULED_TASKS            │
       │  - Subject: task.delay.*            │
       │  - Subject: task.cron.*             │
       └─────────────┬───────────────────────┘
                     │ Queue Subscribe
       ┌─────────────┴───────────────────────┐
       │                                      │
┌──────▼──────┐  ┌──────────┐  ┌──────────┐ │
│  Worker 1   │  │Worker 2  │  │Worker 3  │ │
│ ┌──────────┐│  │          │  │          │ │
│ │  Timing  ││  │          │  │          │ │
│ │  Wheel   ││  │          │  │          │ │
│ │          ││  │          │  │          │ │
│ │ ┌──┐ ┌──┐││  │          │  │          │ │
│ │ │S0│ │S1│││  │          │  │          │ │
│ │ └──┘ └──┘││  │          │  │          │ │
│ └──────────┘│  │          │  │          │ │
└──────┬──────┘  └─────┬────┘  └─────┬────┘ │
       │ Execute       │ Execute      │Execute
       └───────────────┴──────────────┘
                      ↓
       ┌─────────────────────────────────────┐
       │      Task Execution Layer           │
       │  - HTTP Callback                    │
       │  - Message Queue                    │
       │  - Database Update                  │
       └─────────────────────────────────────┘
```

### 時間輪運作流程

```
1. 添加任務
   Client → AddTask(delay=30s)
         ↓
   NATS.Publish("task.delay.xxx", {
       id: "task-123",
       executeAt: now + 30s,
       callback: "http://order-service/timeout"
   })
         ↓
   Worker Subscribe → 加載到時間輪
         ↓
   slot = (currentSlot + 30) % 3600
   wheel[slot].append(task)

2. 指針轉動
   每秒執行：

   tick() {
       currentSlot = (currentSlot + 1) % 3600
       tasks = wheel[currentSlot]

       for task in tasks {
           if task.round == 0 {
               // 時間到，執行任務
               execute(task)
               task.Ack()  // 從 NATS 刪除
           } else {
               // 還需等待，圈數遞減
               task.round--
           }
       }
   }

3. 任務執行
   execute(task) {
       // HTTP 回調
       resp = http.Post(task.callback, task.data)

       if resp.Error {
           // 失敗重試
           retry(task)
       } else {
           // 成功刪除
           removeTask(task)
       }
   }
```

---

## 擴展性分析

### 當前架構（10K 任務/小時）

**配置：**
- Worker: 1 個實例
- 時間輪槽位：3600（1 小時精度）
- NATS: 單機

**性能：**
- 添加任務：O(1)
- 觸發任務：每秒檢查 1 個槽位
- 記憶體：10K 任務 × 1KB ≈ 10 MB

**結論：** 單機足夠 ✅

---

### 10x 擴展（100K 任務/小時）

**瓶頸分析：**
- 時間輪：記憶體操作，可承受
- NATS：單機可處理 100K+ msg/s
- 任務執行：可能成為瓶頸（HTTP 回調延遲）

**方案：水平擴展 Worker**
- 3 個 Worker 實例
- NATS Queue Groups 自動負載均衡
- 每個 Worker 處理 33K 任務

**成本：** $150/月（3 × $50）

---

### 100x 擴展（1M 任務/小時）

**架構升級：**
- 10 個 Worker 實例
- NATS 叢集（3 節點）
- 分層時間輪（優化長延遲任務）

**成本估算：**
- 10 × Worker（c5.large）：$500/月
- 3 × NATS（c5.xlarge）：$450/月
- **總計：$950/月**

---

## 實現範圍標註

### 已實現

| 功能 | 檔案 | 教學重點 |
|------|------|----------|
| **時間輪算法** | `internal/wheel.go:20-150` | 經典調度算法，O(1) 插入與觸發 |
| **延遲任務** | `internal/scheduler.go:30-80` | 計算槽位、圈數 |
| **NATS 持久化** | `internal/scheduler.go:85-120` | At-least-once 語義 |
| **任務執行** | `internal/executor.go:15-60` | HTTP 回調、重試機制 |
| **Cron 解析** | `internal/cron.go:10-50` | 簡化版 Cron（教學用） |
| **HTTP API** | `internal/handler.go:15-100` | 添加任務、查詢狀態 |

### 教學簡化

| 功能 | 原因 | 生產環境建議 |
|------|------|-------------|
| **多層時間輪** | 複雜度高 | 實現分層時間輪，優化長延遲任務 |
| **Cron 完整語法** | 聚焦核心 | 使用 `github.com/robfig/cron` 庫 |
| **分布式鎖** | NATS Queue Groups 已足夠 | 若需更細粒度控制可用 Redis/etcd |
| **任務優先級** | 簡化設計 | 使用多個時間輪或優先級隊列 |
| **監控告警** | 非核心教學 | Prometheus 監控任務堆積、執行延遲 |

### 生產環境額外需要

1. **高可用性**
   - NATS 叢集（3+ 節點）
   - Worker 多實例部署
   - 心跳檢測與自動容錯

2. **監控與告警**
   - 任務堆積數量
   - 執行延遲（實際執行時間 vs 預期時間）
   - 失敗率與重試次數
   - 死信隊列任務數

3. **性能優化**
   - 分層時間輪（秒、分、時、天）
   - 批量執行（合併相同時間的任務）
   - 異步回調（不阻塞時間輪）

4. **安全性**
   - 任務簽名驗證（防止偽造）
   - 回調 URL 白名單
   - 速率限制（防止濫用）

---

## 關鍵設計原則

### 1. 時間輪算法（核心）
- O(1) 插入與觸發
- 記憶體高效
- 廣泛應用（Netty、Kafka）

### 2. 記憶體 + 持久化
- 時間輪：高性能觸發
- NATS：可靠持久化
- 最佳平衡

### 3. 分布式互斥
- Queue Groups：無鎖設計
- 自動負載均衡
- 容錯機制

### 4. 漸進式重試
- 指數退避
- 死信隊列
- 人工介入

---

## 延伸閱讀

### 算法與論文
- [Hashed and Hierarchical Timing Wheels](http://www.cs.columbia.edu/~nahum/w6998/papers/ton97-timing-wheels.pdf)
- Netty HashedWheelTimer 實現
- Kafka Purgatory 機制

### 系統設計問題
- **Phase 7: Message Queue** - 任務持久化基礎
- **Phase 9: Event-Driven** - 事件驅動調度
- **Phase 50: Flash Sale** - 訂單超時處理

### 開源實現
- **Asynq**：Go 分布式任務隊列（基於 Redis）
- **Temporal**：工作流引擎（複雜 DAG 任務）
- **Apache Airflow**：數據管道調度

---

## 總結

### 核心思想
使用**時間輪算法**實現高性能任務調度，結合 **NATS JetStream** 保證可靠性，適合秒級精度的延遲任務與定時任務。

### 適用場景
- ✅ 訂單超時取消（30 分鐘）
- ✅ 會議室預訂釋放（2 小時）
- ✅ 定時報表生成（每日）
- ✅ 數據同步任務（每小時）

### 不適用場景
- ❌ 毫秒級精度（推薦專業調度器）
- ❌ 複雜 DAG 工作流（推薦 Airflow/Temporal）
- ❌ 超大規模（億級任務，推薦分層時間輪）

### 與其他方案對比

| 特性 | 時間輪 + NATS | Redis ZSet | Cron 輪詢 | Quartz |
|------|--------------|-----------|-----------|--------|
| **精度** | 秒級 | 秒級 | 分鐘級 | 秒級 |
| **性能** | 極高（O(1)） | 高 | 低 | 中 |
| **可靠性** | ✅ NATS 持久化 | △ AOF | ✅ DB | ✅ DB |
| **分布式** | ✅ Queue Groups | △ 需額外協調 | ❌ | ✅ |
| **複雜度** | 低 | 低 | 極低 | 高 |
| **適用場景** | 延遲任務 | 簡單延遲 | 定時任務 | 企業調度 |

**結論：** 時間輪 + NATS 在**性能、可靠性、簡單性**之間取得最佳平衡。
