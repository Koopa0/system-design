// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: counters.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const archiveCounterHistory = `-- name: ArchiveCounterHistory :one
INSERT INTO counter_history (
    counter_name, date, final_value, unique_users, metadata
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, counter_name, date, final_value, unique_users, metadata, created_at
`

type ArchiveCounterHistoryParams struct {
	CounterName string      `json:"counter_name"`
	Date        pgtype.Date `json:"date"`
	FinalValue  int64       `json:"final_value"`
	UniqueUsers []byte      `json:"unique_users"`
	Metadata    []byte      `json:"metadata"`
}

// 歸檔計數器歷史記錄
func (q *Queries) ArchiveCounterHistory(ctx context.Context, arg ArchiveCounterHistoryParams) (CounterHistory, error) {
	row := q.db.QueryRow(ctx, archiveCounterHistory,
		arg.CounterName,
		arg.Date,
		arg.FinalValue,
		arg.UniqueUsers,
		arg.Metadata,
	)
	var i CounterHistory
	err := row.Scan(
		&i.ID,
		&i.CounterName,
		&i.Date,
		&i.FinalValue,
		&i.UniqueUsers,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const cleanOldQueue = `-- name: CleanOldQueue :exec
DELETE FROM write_queue
WHERE processed = TRUE 
  AND created_at < NOW() - INTERVAL '1 hour'
`

// 清理已處理的舊佇列項目
func (q *Queries) CleanOldQueue(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanOldQueue)
	return err
}

const createCounter = `-- name: CreateCounter :one
INSERT INTO counters (
    name, counter_type, metadata
) VALUES (
    $1, $2::counter_type, $3
) ON CONFLICT (name) DO NOTHING
RETURNING id, name, current_value, counter_type, metadata, created_at, updated_at
`

type CreateCounterParams struct {
	Name     string      `json:"name"`
	Column2  CounterType `json:"column_2"`
	Metadata []byte      `json:"metadata"`
}

// 創建新的計數器
func (q *Queries) CreateCounter(ctx context.Context, arg CreateCounterParams) (Counter, error) {
	row := q.db.QueryRow(ctx, createCounter, arg.Name, arg.Column2, arg.Metadata)
	var i Counter
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CurrentValue,
		&i.CounterType,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const decrementCounter = `-- name: DecrementCounter :one
UPDATE counters 
SET current_value = GREATEST(0, current_value - $2),
    updated_at = NOW()
WHERE name = $1
RETURNING current_value
`

type DecrementCounterParams struct {
	Name         string      `json:"name"`
	CurrentValue pgtype.Int8 `json:"current_value"`
}

// 原子性減少計數器值
func (q *Queries) DecrementCounter(ctx context.Context, arg DecrementCounterParams) (pgtype.Int8, error) {
	row := q.db.QueryRow(ctx, decrementCounter, arg.Name, arg.CurrentValue)
	var current_value pgtype.Int8
	err := row.Scan(&current_value)
	return current_value, err
}

const deleteOldHistory = `-- name: DeleteOldHistory :exec
DELETE FROM counter_history
WHERE date < CURRENT_DATE - INTERVAL '7 days'
`

// 刪除超過 7 天的歷史記錄
func (q *Queries) DeleteOldHistory(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteOldHistory)
	return err
}

const dequeueWrites = `-- name: DequeueWrites :many
SELECT id, counter_name, operation, value, user_id, metadata, processed, created_at FROM write_queue
WHERE processed = FALSE
ORDER BY created_at
LIMIT $1
FOR UPDATE SKIP LOCKED
`

// 獲取未處理的寫入操作
func (q *Queries) DequeueWrites(ctx context.Context, limit int32) ([]WriteQueue, error) {
	rows, err := q.db.Query(ctx, dequeueWrites, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WriteQueue{}
	for rows.Next() {
		var i WriteQueue
		if err := rows.Scan(
			&i.ID,
			&i.CounterName,
			&i.Operation,
			&i.Value,
			&i.UserID,
			&i.Metadata,
			&i.Processed,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const enqueueWrite = `-- name: EnqueueWrite :one
INSERT INTO write_queue (
    counter_name, operation, value, user_id, metadata
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, counter_name, operation, value, user_id, metadata, processed, created_at
`

type EnqueueWriteParams struct {
	CounterName string      `json:"counter_name"`
	Operation   string      `json:"operation"`
	Value       int64       `json:"value"`
	UserID      pgtype.Text `json:"user_id"`
	Metadata    []byte      `json:"metadata"`
}

// 將寫入操作加入佇列（降級模式使用）
func (q *Queries) EnqueueWrite(ctx context.Context, arg EnqueueWriteParams) (WriteQueue, error) {
	row := q.db.QueryRow(ctx, enqueueWrite,
		arg.CounterName,
		arg.Operation,
		arg.Value,
		arg.UserID,
		arg.Metadata,
	)
	var i WriteQueue
	err := row.Scan(
		&i.ID,
		&i.CounterName,
		&i.Operation,
		&i.Value,
		&i.UserID,
		&i.Metadata,
		&i.Processed,
		&i.CreatedAt,
	)
	return i, err
}

const getCounter = `-- name: GetCounter :one
SELECT id, name, current_value, counter_type, metadata, created_at, updated_at FROM counters
WHERE name = $1 LIMIT 1
`

// 獲取單個計數器的當前值
func (q *Queries) GetCounter(ctx context.Context, name string) (Counter, error) {
	row := q.db.QueryRow(ctx, getCounter, name)
	var i Counter
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CurrentValue,
		&i.CounterType,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCounterHistory = `-- name: GetCounterHistory :many
SELECT id, counter_name, date, final_value, unique_users, metadata, created_at FROM counter_history
WHERE counter_name = $1 
  AND date >= $2 
  AND date <= $3
ORDER BY date DESC
`

type GetCounterHistoryParams struct {
	CounterName string      `json:"counter_name"`
	Date        pgtype.Date `json:"date"`
	Date_2      pgtype.Date `json:"date_2"`
}

// 查詢計數器歷史
func (q *Queries) GetCounterHistory(ctx context.Context, arg GetCounterHistoryParams) ([]CounterHistory, error) {
	rows, err := q.db.Query(ctx, getCounterHistory, arg.CounterName, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CounterHistory{}
	for rows.Next() {
		var i CounterHistory
		if err := rows.Scan(
			&i.ID,
			&i.CounterName,
			&i.Date,
			&i.FinalValue,
			&i.UniqueUsers,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCounters = `-- name: GetCounters :many
SELECT id, name, current_value, counter_type, metadata, created_at, updated_at FROM counters
WHERE name = ANY($1::text[])
`

// 批量獲取多個計數器
func (q *Queries) GetCounters(ctx context.Context, dollar_1 []string) ([]Counter, error) {
	rows, err := q.db.Query(ctx, getCounters, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Counter{}
	for rows.Next() {
		var i Counter
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CurrentValue,
			&i.CounterType,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementCounter = `-- name: IncrementCounter :one
UPDATE counters 
SET current_value = current_value + $2,
    updated_at = NOW()
WHERE name = $1
RETURNING current_value
`

type IncrementCounterParams struct {
	Name         string      `json:"name"`
	CurrentValue pgtype.Int8 `json:"current_value"`
}

// 原子性增加計數器值
func (q *Queries) IncrementCounter(ctx context.Context, arg IncrementCounterParams) (pgtype.Int8, error) {
	row := q.db.QueryRow(ctx, incrementCounter, arg.Name, arg.CurrentValue)
	var current_value pgtype.Int8
	err := row.Scan(&current_value)
	return current_value, err
}

const listCounters = `-- name: ListCounters :many
SELECT id, name, current_value, counter_type, metadata, created_at, updated_at FROM counters
ORDER BY name
LIMIT $1 OFFSET $2
`

type ListCountersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

// 列出所有計數器
func (q *Queries) ListCounters(ctx context.Context, arg ListCountersParams) ([]Counter, error) {
	rows, err := q.db.Query(ctx, listCounters, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Counter{}
	for rows.Next() {
		var i Counter
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CurrentValue,
			&i.CounterType,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markWriteProcessed = `-- name: MarkWriteProcessed :exec
UPDATE write_queue
SET processed = TRUE
WHERE id = $1
`

// 標記寫入操作為已處理
func (q *Queries) MarkWriteProcessed(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, markWriteProcessed, id)
	return err
}

const resetCounter = `-- name: ResetCounter :exec
UPDATE counters 
SET current_value = 0,
    updated_at = NOW()
WHERE name = $1
`

// 重置計數器為 0
func (q *Queries) ResetCounter(ctx context.Context, name string) error {
	_, err := q.db.Exec(ctx, resetCounter, name)
	return err
}

const setCounter = `-- name: SetCounter :exec
UPDATE counters 
SET current_value = $2,
    updated_at = NOW()
WHERE name = $1
`

type SetCounterParams struct {
	Name         string      `json:"name"`
	CurrentValue pgtype.Int8 `json:"current_value"`
}

// 直接設置計數器值（用於從 Redis 同步）
func (q *Queries) SetCounter(ctx context.Context, arg SetCounterParams) error {
	_, err := q.db.Exec(ctx, setCounter, arg.Name, arg.CurrentValue)
	return err
}
