# URL Shortener 系統設計學習指南

> 將長網址縮短為易於分享的短鏈接（如 `bit.ly/abc123`）

## 📋 目錄

1. [問題理解](#問題理解)
2. [需求分析](#需求分析)
3. [容量估算](#容量估算)
4. [高層設計](#高層設計)
5. [深入設計](#深入設計)
6. [權衡取捨](#權衡取捨)
7. [擴展性](#擴展性)
8. [面試要點](#面試要點)

---

## 問題理解

### 什麼是 URL Shortener？

URL Shortener 將長網址轉換為短鏈接：

```
原始 URL（長）：
https://www.example.com/articles/2024/system-design/how-to-build-url-shortener?utm_source=twitter&utm_campaign=promo

短網址：
https://short.url/abc123
```

### 核心功能

1. **縮短 URL**：給定長網址，生成短碼
2. **重定向**：訪問短網址，跳轉到原始網址
3. **統計**（可選）：追蹤點擊次數、來源等

### 真實案例

- **Bitly**：最流行的短網址服務
- **TinyURL**：最早的短網址服務之一
- **Twitter**：t.co（自動縮短推文中的鏈接）
- **YouTube**：youtu.be（分享視頻用）

---

## 需求分析

### 功能性需求

**必須（Must Have）**：
1. ✅ 給定長 URL，返回唯一的短 URL
2. ✅ 訪問短 URL，重定向到長 URL
3. ✅ 短 URL 應該儘可能短

**應該（Should Have）**：
4. 🔹 自定義短碼（如 `bit.ly/google-io`）
5. 🔹 過期時間設置
6. 🔹 點擊統計

**可以（Nice to Have）**：
7. 📊 詳細分析（地理位置、設備、時間）
8. 📊 API 接口
9. 📊 用戶系統

### 非功能性需求

**性能**：
- **高可用**：99.9% 可用性（服務不能掛）
- **低延遲**：重定向 < 100ms（用戶體驗）
- **高吞吐**：支持高 QPS（熱門鏈接）

**規模**：
- **存儲**：數十億條 URL
- **流量**：讀多寫少（100:1 或更高）

**安全**：
- 防止濫用（限流、驗證碼）
- 防止惡意鏈接（釣魚、病毒）

---

## 容量估算

### 假設

讓我們估算一個中等規模的短網址服務：

**用戶與流量**：
- DAU（日活用戶）：**1000 萬**
- 每用戶每天創建：**0.1 個**短鏈（大部分人是訪問者）
- 每用戶每天點擊：**5 個**短鏈

### QPS 計算

**寫入（創建短鏈）**：
```
每天新增 = 1000萬 × 0.1 = 100 萬條
QPS = 100萬 / 86400秒 ≈ 12 QPS
峰值 QPS = 12 × 2 ≈ 24 QPS
```

**讀取（重定向）**：
```
每天點擊 = 1000萬 × 5 = 5000 萬次
QPS = 5000萬 / 86400秒 ≈ 580 QPS
峰值 QPS = 580 × 2 ≈ 1160 QPS
```

**讀寫比**：580 / 12 ≈ **50:1**（典型的讀多寫少）

### 存儲容量

**5 年存儲需求**：
```
每天新增：100 萬條
5 年總量：100萬 × 365 × 5 ≈ 18 億條

每條記錄大小：
  - ID: 8 bytes
  - short_code: 8 bytes
  - long_url: 平均 200 bytes
  - 其他字段: 32 bytes
  - 總計: ~250 bytes

總存儲：18億 × 250B ≈ 450 GB
```

**加上索引**（約 30%）：450GB × 1.3 ≈ **600 GB**

### 帶寬需求

**寫入**：
```
QPS: 12
每個請求: 200 bytes（URL）
帶寬: 12 × 200B ≈ 2.4 KB/s
```

**讀取**：
```
QPS: 580
每個請求: 500 bytes（HTTP 重定向）
帶寬: 580 × 500B ≈ 290 KB/s
```

### 快取需求（80/20 法則）

```
熱點數據（20%）：18億 × 0.2 = 3.6 億條
快取大小：3.6億 × 250B ≈ 90 GB
```

實際上，快取可以更小（只快取最熱的 1%）：
```
1% 數據：18億 × 0.01 = 1800 萬條
快取大小：1800萬 × 250B ≈ 4.5 GB
```

---

## 高層設計

### API 設計

**1. 創建短網址**
```http
POST /api/v1/urls
Content-Type: application/json

{
  "long_url": "https://example.com/very/long/url",
  "custom_code": "my-link",      // 可選
  "expires_at": "2024-12-31T..."  // 可選
}

Response: 201 Created
{
  "short_url": "https://short.url/my-link",
  "short_code": "my-link",
  "long_url": "https://example.com/very/long/url",
  "created_at": "2024-01-01T..."
}
```

**2. 重定向**
```http
GET /{shortCode}

Response: 302 Found
Location: https://example.com/very/long/url
```

**3. 統計查詢**
```http
GET /api/v1/urls/{shortCode}/stats

Response: 200 OK
{
  "short_code": "my-link",
  "clicks": 1234,
  "created_at": "2024-01-01T..."
}
```

### 數據模型

**URLs 表**：
```sql
CREATE TABLE urls (
  id          BIGINT PRIMARY KEY,      -- Snowflake ID
  short_code  VARCHAR(20) UNIQUE,      -- 短碼
  long_url    TEXT NOT NULL,           -- 原始 URL
  clicks      BIGINT DEFAULT 0,        -- 點擊次數
  created_at  TIMESTAMP NOT NULL,
  expires_at  TIMESTAMP                -- 過期時間（可選）
);

CREATE INDEX idx_short_code ON urls(short_code);
CREATE INDEX idx_created_at ON urls(created_at);
```

### 架構圖

```
┌─────────┐
│  用戶   │
└────┬────┘
     │
     │ ① 創建 / ② 訪問
     ↓
┌────────────────┐
│  負載均衡器    │  (nginx / ALB)
└────┬───────────┘
     │
     │ ③ 路由
     ↓
┌────────────────────────────┐
│     應用服務器集群          │  (無狀態)
│  ┌─────┐ ┌─────┐ ┌─────┐  │
│  │ App │ │ App │ │ App │  │
│  └─────┘ └─────┘ └─────┘  │
└─────┬──────────────┬───────┘
      │              │
      │ ④ 查詢       │ ⑤ 寫入
      ↓              ↓
┌──────────┐   ┌──────────────┐
│  Redis   │   │  PostgreSQL  │
│ (快取)   │←──│  (主存儲)    │
└──────────┘   └──────────────┘
  (熱數據)        (全部數據)
```

**流程說明**：

1. **創建短網址**：
   ```
   用戶 → 應用 → 生成 ID → 編碼為短碼 → 寫入 DB → 返回結果
   ```

2. **訪問短網址**：
   ```
   用戶 → 應用 → 查 Redis → 命中？返回 : 查 DB → 寫 Redis → 返回
                             ↓
                        統計點擊（異步）
   ```

---

## 深入設計

### 1. 短碼生成策略

這是最核心的設計問題！

#### 方案 A：哈希（Hash）

**原理**：
```
long_url → MD5/SHA256 → 取前 7 位 → Base62 編碼
```

**優點**：
- ✅ 實現簡單
- ✅ 相同 URL 生成相同短碼（冪等）

**缺點**：
- ❌ 可能衝突（需要處理）
- ❌ 無法保證遞增（索引性能差）
- ❌ 長度不可控

#### 方案 B：自增 ID

**原理**：
```
資料庫自增 ID → Base62 編碼
```

**優點**：
- ✅ 無衝突
- ✅ 短碼長度可預測
- ✅ 實現簡單

**缺點**：
- ❌ 單點故障（資料庫）
- ❌ 可預測（安全問題）
- ❌ 擴展性差（難以水平擴展）

#### 方案 C：分布式 ID（Snowflake）✅

**原理**：
```
Snowflake ID（64 bit）→ Base62 編碼

Snowflake 結構：
[0][41 bit 時間戳][10 bit 機器 ID][12 bit 序列號]
```

**優點**：
- ✅ 全局唯一
- ✅ 趨勢遞增（索引友好）
- ✅ 無需中心協調（高性能）
- ✅ 可水平擴展（1024 台機器）

**缺點**：
- ⚠️ 需要機器 ID 管理
- ⚠️ 時鐘回撥問題

**本項目選擇**：✅ Snowflake

#### Base62 編碼

**為什麼用 Base62 而非 Base64？**

```
Base62 字符集：0-9, A-Z, a-z（62 個字符）
Base64 字符集：0-9, A-Z, a-z, +, /（64 個字符）
```

- **URL 安全**：Base62 不包含 `+` 和 `/`，無需轉義
- **可讀性**：僅字母數字，更友好
- **容量充足**：62^7 = 3.5 兆，足夠使用

**長度計算**：
```
6 位：62^6  = 568 億
7 位：62^7  = 3.5 兆
8 位：62^8  = 218 兆
```

對於 Snowflake ID（最大 2^63-1），Base62 編碼後約 **10-11 位**。

### 2. 重定向策略

#### 301 vs 302 重定向

**301 Moved Permanently（永久重定向）**：
- 瀏覽器會快取
- 後續訪問直接從快取跳轉
- **無法統計點擊**

**302 Found（臨時重定向）**：
- 每次都經過服務器
- **可以統計點擊**
- 略慢（多一次網絡請求）

**本項目選擇**：✅ 302（優先統計能力）

### 3. 快取策略

#### Cache-Aside（旁路快取）

**讀取流程**：
```
1. 查詢 Redis
2. 命中？返回
3. 未命中：查詢 DB
4. 寫入 Redis（設置 TTL）
5. 返回結果
```

**寫入流程**：
```
1. 寫入 DB
2. 刪除 / 更新 Redis
```

**TTL 設置**：
- **熱點數據**：1 小時（平衡命中率與一致性）
- **冷數據**：不快取（減少內存浪費）

**快取穿透防護**：
```
短碼不存在時，快取空結果（TTL 1 分鐘）
```

### 4. 點擊統計

#### 同步 vs 異步

**同步更新**：
```go
func Redirect() {
    url := LoadFromDB(shortCode)
    IncrementClicks(shortCode)  // 阻塞
    Redirect(url)
}
```
- ❌ 阻塞重定向
- ❌ 影響性能

**異步更新**（本項目）：
```go
func Redirect() {
    url := LoadFromDB(shortCode)
    go IncrementClicks(shortCode)  // 非阻塞
    Redirect(url)
}
```
- ✅ 不阻塞重定向
- ⚠️ 允許統計延遲

**更好的方案**（生產環境）：
```
用戶訪問 → 發送事件到消息隊列 → 批量更新 DB
             (NATS/Kafka)          (每 10 秒聚合一次)
```

### 5. 過期處理

#### 主動刪除 vs 惰性刪除

**主動刪除**：
```
定期任務（每小時）：
DELETE FROM urls WHERE expires_at < NOW()
```
- ✅ 及時釋放存儲
- ❌ 掃描開銷大

**惰性刪除**（本項目）：
```
訪問時檢查：
if url.IsExpired() {
    return ErrExpired
}
```
- ✅ 無額外開銷
- ⚠️ 過期數據仍佔存儲

**組合方案**：
```
1. 訪問時檢查（惰性）
2. 定期批量清理（主動）
```

---

## 權衡取捨

### 一致性 vs 性能

**場景**：點擊統計

**選擇 A：強一致性**
```go
func Redirect() {
    tx := db.Begin()
    url := tx.Load(shortCode)
    tx.IncrementClicks(shortCode)
    tx.Commit()
    Redirect(url)
}
```
- ✅ 統計絕對準確
- ❌ 性能差（事務開銷）
- ❌ 延遲高（阻塞）

**選擇 B：最終一致性**（本項目）
```go
func Redirect() {
    url := LoadFromCache(shortCode)
    go IncrementClicks(shortCode)  // 異步
    Redirect(url)
}
```
- ✅ 性能優秀（< 10ms）
- ✅ 用戶體驗好
- ⚠️ 統計可能延遲
- ⚠️ 極端情況可能丟失

**為什麼選擇 B？**
- 統計允許不精確（差幾個點擊無所謂）
- 重定向速度更重要（用戶體驗）
- 可以通過日誌系統補充分析

### 簡潔 vs 安全

**場景**：短碼生成

**選擇 A：自增 ID**
```
短碼可預測：abc123 → abc124 → abc125
```
- ✅ 實現簡單
- ❌ 可遍歷（安全問題）
- ❌ 暴露業務量（abc999 說明有 999+ 短鏈）

**選擇 B：隨機 / Snowflake**（本項目）
```
短碼不可預測：8M0kX → kF2pL → Zx9nQ
```
- ✅ 無法猜測下一個短碼
- ✅ 不暴露業務數據
- ⚠️ 實現稍複雜

### 成本 vs 性能

**場景**：快取大小

**選擇 A：快取全部數據**
```
18 億條 × 250B = 450 GB Redis
```
- ✅ 命中率 100%
- ❌ 成本極高
- ❌ 浪費（冷數據佔 80%）

**選擇 B：快取熱點數據**（本項目）
```
1% 數據 = 4.5 GB Redis
```
- ✅ 成本低（< $100/月）
- ✅ 命中率仍很高（>95%）
- ⚠️ 冷數據需查 DB

**為什麼選擇 B？**
- 80/20 法則：20% 的短鏈產生 80% 的流量
- 實際上 1% 的熱點數據可能佔 50% 流量
- 成本節省 99%，性能僅略降

---

## 擴展性

### 水平擴展策略

#### 應用層（無狀態）

```
           ┌────────┐
           │  LB    │
           └───┬────┘
       ┌───────┼───────┐
       ↓       ↓       ↓
     [App1] [App2] [App3]  ← 可無限擴展
```

- ✅ 簡單：加機器即可
- ✅ 無瓶頸：應用無狀態

#### 快取層（Redis Cluster）

**單機 Redis 瓶頸**：
```
QPS: ~100,000
內存: 最大 512 GB
```

**Redis Cluster**：
```
          ┌─────────┐
          │  App    │
          └────┬────┘
               │
       ┌───────┼───────┐
       ↓       ↓       ↓
    [Redis] [Redis] [Redis]
    Shard1  Shard2  Shard3
```

- 分片規則：CRC16(short_code) % 16384
- 擴展：增加節點，自動重新分片

#### 資料庫層（Sharding）

**單機 PostgreSQL 瓶頸**：
```
QPS: ~10,000-50,000
存儲: 1-2 TB（合理範圍）
```

**當數據量達到 10 億+，需要分片**：

**方案 1：按 short_code 哈希**
```
Shard = Hash(short_code) % N

示例（N=4）：
  short_code="8M0kX" → Hash → 2 → Shard2
  short_code="kF2pL" → Hash → 0 → Shard0
```

- ✅ 負載均勻
- ❌ 無法範圍查詢
- ❌ 重新分片困難

**方案 2：按 ID 範圍**
```
Shard0: ID 0 ~ 1000000000
Shard1: ID 1000000001 ~ 2000000000
...
```

- ✅ 範圍查詢友好
- ❌ 新數據集中在某分片（熱點）

**方案 3：一致性哈希**
```
使用一致性哈希環分配數據
```

- ✅ 易於擴容（影響少量數據）
- ⚠️ 實現複雜

**本項目建議**：方案 1（哈希分片）

### 多區域部署

```
     ┌─────────────────────────┐
     │  Global Load Balancer  │
     └────────┬────────────────┘
              │
      ┌───────┴──────┐
      ↓              ↓
  [US East]      [EU West]
   DB + Cache    DB + Cache
```

- **寫入**：主區域（單一真相源）
- **讀取**：就近訪問（CDN + 本地快取）

---

## 面試要點

### 面試流程

**1. 需求澄清（3-5 分鐘）**

問題清單：
- Q: 短網址的格式？
  - A: `https://domain.com/{shortCode}`

- Q: 短碼長度？
  - A: 儘可能短，6-8 字符

- Q: 需要自定義短碼嗎？
  - A: 可選功能

- Q: 需要統計嗎？
  - A: 需要點擊次數

- Q: 過期機制？
  - A: 支持設置過期時間

- Q: 預期 QPS？
  - A: 寫 100 QPS，讀 10,000 QPS

**2. 容量估算（5 分鐘）**

展示計算：
```
DAU: 1000 萬
寫 QPS: 12
讀 QPS: 580
存儲（5 年）: 600 GB
快取: 4.5 GB
```

**3. 高層設計（10 分鐘）**

畫出架構圖：
- 客戶端
- 負載均衡
- 應用服務器
- Redis（快取）
- PostgreSQL（存儲）

說明核心流程：
1. 創建短網址
2. 訪問短網址

**4. 深入設計（15-20 分鐘）**

重點討論：

a) **短碼生成**（必問）：
   - 哈希 vs 自增 vs Snowflake
   - 為什麼選擇 Snowflake？
   - Base62 編碼原理

b) **資料庫設計**：
   - 表結構
   - 索引策略
   - 為什麼 short_code 需要 UNIQUE？

c) **快取策略**：
   - Cache-Aside 模式
   - TTL 設置
   - 快取穿透防護

d) **性能優化**：
   - 異步統計
   - 讀寫分離
   - CDN 加速

**5. 擴展與權衡（5-10 分鐘）**

討論：
- 水平擴展方案
- 資料庫分片策略
- 一致性 vs 性能權衡

### 常見追問

**Q1: 如何處理熱點 URL？**

A: 多層快取
```
本地快取（進程內 LRU，100ms TTL）
   ↓ Miss
Redis（1h TTL）
   ↓ Miss
資料庫
```

**Q2: 如何防止濫用？**

A: 限流策略
```
- IP 限流：每 IP 每小時最多 100 次創建
- 用戶限流：每用戶每天最多 1000 次創建
- 驗證碼：異常流量時啟用
```

**Q3: 如何保證短碼唯一性？**

A: 多重保證
```
1. Snowflake 本身唯一（時間 + 機器 + 序列）
2. 資料庫 UNIQUE 約束（最後防線）
3. 衝突重試（極端情況）
```

**Q4: 短碼可以回收嗎？**

A: 可以，但要謹慎
```
過期 URL 的短碼可以回收
但需要：
  1. 足夠長的冷卻期（如 1 年）
  2. 避免原用戶誤訪問
  3. 實際上不回收更安全（短碼空間充足）
```

**Q5: 如何支持分析功能？**

A: 事件驅動架構
```
訪問 → 發送事件 → 消息隊列 → 流處理 → 數據倉庫
                  (Kafka)    (Flink)   (ClickHouse)
```

### 評分標準

**基礎（60 分）**：
- ✅ 畫出基本架構圖
- ✅ 設計 API
- ✅ 設計資料庫表
- ✅ 說明基本流程

**良好（75 分）**：
- ✅ 討論短碼生成策略
- ✅ 設計快取層
- ✅ 考慮性能優化

**優秀（90 分）**：
- ✅ 容量估算準確
- ✅ 深入討論權衡取捨
- ✅ 設計水平擴展方案
- ✅ 處理邊界情況

---

## 參考資料

**必讀**：
1. [ByteByteGo - Designing a URL Shortener](https://bytebytego.com/)
2. [Grokking the System Design Interview - URL Shortener](https://www.designgurus.io/)

**深入學習**：
3. [Bitly 架構演進](https://word.bitly.com/)
4. [Twitter Snowflake](https://blog.twitter.com/engineering/en_us/a/2010/announcing-snowflake)
5. [DDIA Chapter 6: Partitioning](https://dataintensive.net/)

**實作參考**：
6. 本項目代碼（Go 實現）
7. [System Design Primer](https://github.com/donnemartin/system-design-primer)

---

## 總結

URL Shortener 是一個**經典的系統設計題目**，涵蓋了：

✅ **ID 生成**：分布式唯一 ID（Snowflake）
✅ **編碼**：Base62（URL 安全）
✅ **快取**：Cache-Aside（性能優化）
✅ **權衡**：一致性 vs 性能
✅ **擴展**：水平擴展、資料庫分片

**關鍵要點**：
1. **讀多寫少**（100:1）→ 優化讀取路徑
2. **短碼唯一**  → Snowflake + UNIQUE 約束
3. **低延遲**    → 多層快取
4. **可擴展**    → 無狀態應用 + 分片資料庫

**面試建議**：
- 先問需求（不要假設）
- 估算容量（展示思考）
- 畫架構圖（清晰表達）
- 討論權衡（沒有完美方案）
- 深入細節（展現深度）

祝你面試成功！🎉
